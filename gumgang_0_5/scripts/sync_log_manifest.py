#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
sync_log_manifest.py — Gumgang 2.0
Utility to sync logs/manifest timestamps using project KST util and append missing changesets/audit lines.

- All timestamps MUST be generated by backend/utils/time_kr.now_kr_str_minute (Asia/Seoul, "YYYY-MM-DD HH:mm")
- Appends missing entries for known recent tasks into:
  * .session/session_manifest.json (changesets, timestamps.updated_at_kst)
  * logs/guard_audit.log (tab-separated audit lines; ensures header exists)
- Only writes existing paths (verifies file existence before recording).
- Idempotent: skips duplicates (by task_id + path).
- Dry-run supported.

Usage:
  python scripts/sync_log_manifest.py            # real run
  python scripts/sync_log_manifest.py --dry-run  # no file changes, just report
"""

from __future__ import annotations

import argparse
import json
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any


# -------------------------
# Project root & imports
# -------------------------

SCRIPT_PATH = Path(__file__).resolve()
ROOT = SCRIPT_PATH.parents[1]  # gumgang_0_5/
BACKEND_DIR = ROOT / "backend"
SESSION_DIR = ROOT / ".session"
LOGS_DIR = ROOT / "logs"

# Ensure we can import the KST time util
sys.path.insert(0, str(BACKEND_DIR))  # so 'utils.time_kr' is importable
try:
    from utils.time_kr import now_kr_str_minute  # type: ignore
except Exception as e:
    print(f"[ERROR] Cannot import backend/utils/time_kr.now_kr_str_minute: {e}")
    sys.exit(1)


# -------------------------
# Data models
# -------------------------

@dataclass
class TaskSpec:
    task_id: str
    notes: str
    paths: List[str]
    operation: str = "edit"  # default
    # risk, status, etc. for guard_audit
    risk: str = "SAFE"
    message: Optional[str] = None


# -------------------------
# Helpers
# -------------------------

def load_json(path: Path, default: Any) -> Any:
    if not path.exists():
        return default
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        print(f"[WARN] Failed to parse JSON at {path}: {e}")
        return default


def save_json(path: Path, data: Any, dry_run: bool) -> None:
    payload = json.dumps(data, ensure_ascii=False, indent=2)
    if dry_run:
        print(f"[DRY-RUN] Would write JSON to {path}:\n{payload}")
    else:
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(payload + "\n", encoding="utf-8")
        print(f"[OK] Wrote JSON: {path}")


def ensure_guard_header(log_path: Path, dry_run: bool) -> None:
    header_lines = [
        "# Gumgang 2.0 — Guard Audit Log",
        "# File: logs/guard_audit.log",
        "# Encoding: UTF-8",
        "# Delimiter: TAB",
        "# Timezone: Asia/Seoul (KST)",
        '# Timestamp format: YYYY-MM-DD HH:mm (MUST be generated by backend/utils/time_kr.now_kr_str_minute)',
        "# Write policy: Append-only, one event per line",
        "# Purpose: Record all guarded actions with task_id and verification data for audit and rollback",
        "# Notes:",
        "# - Do NOT remove or modify this header.",
        "# - All entries MUST pass through the approval→guard→execute→verify pipeline.",
        "# - This file may be tailed by monitoring tools.",
        "",
        "ts_kst\ttask_id\tactor\tphase\toperation\trisk\tpath\tstatus\tmessage\trules_version\tsession_id\tblueprint_sha",
    ]
    if not log_path.exists():
        content = "\n".join(header_lines) + "\n"
        if dry_run:
            print(f"[DRY-RUN] Would create guard log with header at {log_path}")
        else:
            log_path.parent.mkdir(parents=True, exist_ok=True)
            log_path.write_text(content, encoding="utf-8")
            print(f"[OK] Created guard log with header: {log_path}")
        return

    # If exists, ensure header row present (by searching the schema line)
    text = log_path.read_text(encoding="utf-8", errors="ignore")
    schema_line = "ts_kst\ttask_id\tactor\tphase\toperation\trisk\tpath\tstatus\tmessage\trules_version\tsession_id\tblueprint_sha"
    if schema_line not in text:
        # Prepend header
        new_text = "\n".join(header_lines) + "\n" + text
        if dry_run:
            print(f"[DRY-RUN] Would prepend header to existing guard log at {log_path}")
        else:
            log_path.write_text(new_text, encoding="utf-8")
            print(f"[OK] Prepended guard log header: {log_path}")


def read_guard_existing_keys(log_path: Path) -> set[Tuple[str, str]]:
    """
    Returns a set of (task_id, path) already present in guard log (to avoid duplicates).
    """
    keys: set[Tuple[str, str]] = set()
    if not log_path.exists():
        return keys
    try:
        for line in log_path.read_text(encoding="utf-8", errors="ignore").splitlines():
            if not line or line.startswith("#") or line.startswith("ts_kst\t"):
                continue
            parts = line.split("\t")
            if len(parts) >= 7:
                task_id = parts[1].strip()
                path = parts[6].strip()
                if task_id and path:
                    keys.add((task_id, path))
    except Exception:
        pass
    return keys


def append_guard_entries(
    log_path: Path,
    ts_kst: str,
    tasks: List[TaskSpec],
    rules_version_str: str,
    session_id: str,
    blueprint_sha: str,
    dry_run: bool,
) -> int:
    """
    Append audit entries for missing (task_id, path) pairs. Returns count appended.
    """
    ensure_guard_header(log_path, dry_run)
    existing = read_guard_existing_keys(log_path)

    lines_to_append: List[str] = []
    actor = "gpt-5"
    phase = "execute"
    for t in tasks:
        for p in t.paths:
            key = (t.task_id, p)
            if key in existing:
                continue
            message = t.message or t.notes
            cols = [
                ts_kst,
                t.task_id,
                actor,
                phase,
                t.operation,
                t.risk,
                p,
                "success",
                message.replace("\t", " ").strip(),
                rules_version_str,
                session_id,
                blueprint_sha,
            ]
            lines_to_append.append("\t".join(cols))

    if not lines_to_append:
        print("[INFO] No new guard entries to append.")
        return 0

    payload = "\n".join(lines_to_append) + "\n"
    if dry_run:
        print(f"[DRY-RUN] Would append {len(lines_to_append)} guard entries to {log_path}:\n{payload}")
    else:
        with log_path.open("a", encoding="utf-8") as f:
            f.write(payload)
        print(f"[OK] Appended {len(lines_to_append)} guard entries to {log_path}")
    return len(lines_to_append)


def normalize_rules_version(manifest: Dict[str, Any]) -> str:
    # Prefer session manifest guard.rules_version if present.
    rv = (manifest.get("guard") or {}).get("rules_version") or "1.1"
    return rv if str(rv).startswith("v") else f"v{rv}"


def existing_paths_only(paths: List[str]) -> List[str]:
    out: List[str] = []
    for p in paths:
        full = ROOT / p
        if full.exists():
            out.append(p)
        else:
            print(f"[WARN] Path not found, skipping: {p}")
    return out


def upsert_changeset(
    manifest: Dict[str, Any],
    task: TaskSpec,
    ts_kst: str,
) -> bool:
    """
    Upsert a changeset for task. Returns True if manifest modified.
    """
    modified = False
    changesets: List[Dict[str, Any]] = manifest.setdefault("changesets", [])
    # find existing by task_id
    idx = next((i for i, cs in enumerate(changesets) if cs.get("task_id") == task.task_id), None)
    # filter to existing paths only
    valid_paths = existing_paths_only(task.paths)
    if idx is None:
        # Insert new
        entry = {
            "task_id": task.task_id,
            "ts_kst": ts_kst,
            "operation": task.operation,
            "paths": valid_paths,
            "status": "success",
            "notes": task.notes,
        }
        changesets.append(entry)
        print(f"[OK] Added changeset: {task.task_id} ({len(valid_paths)} paths)")
        modified = True
    else:
        cs = changesets[idx]
        # ts_kst fill (only if empty or '미확인')
        if not cs.get("ts_kst") or str(cs.get("ts_kst")).strip() == "미확인":
            cs["ts_kst"] = ts_kst
            modified = True
            print(f"[OK] Filled ts_kst for changeset: {task.task_id}")
        # merge paths
        current_paths = set(cs.get("paths") or [])
        addable = [p for p in valid_paths if p not in current_paths]
        if addable:
            cs["paths"] = list(current_paths.union(addable))
            modified = True
            print(f"[OK] Extended paths for changeset {task.task_id}: +{len(addable)}")
        # ensure notes present
        if not cs.get("notes"):
            cs["notes"] = task.notes
            modified = True
    return modified


def sync_manifest_and_logs(dry_run: bool = False) -> None:
    # Paths
    manifest_path = SESSION_DIR / "session_manifest.json"
    session_current_path = SESSION_DIR / "SESSION_CURRENT.json"
    guard_log_path = LOGS_DIR / "guard_audit.log"

    # Load configs
    manifest = load_json(manifest_path, default={})
    session_current = load_json(session_current_path, default={})

    # Collect meta
    ts_kst = now_kr_str_minute()  # KST timestamp (format enforced by util)
    rules_version_str = normalize_rules_version(manifest)
    session_id = str(session_current.get("session_id", "미확인"))
    blueprint_sha = str(session_current.get("blueprint_sha", "미확인"))

    # Prepare task specs (paths will be verified on disk)
    tasks: List[TaskSpec] = [
        TaskSpec(
            task_id="G2-UI-EXT",
            notes="WS-only memory status default; remove polling unless env flag; improve connection/error UX; add ConnectionStatus and top bar integration",
            paths=[
                "gumgang-v2/components/layout/MemoryStatus.tsx",
                "gumgang-v2/app/dashboard/page.tsx",
                "gumgang-v2/contexts/WebSocketContext.tsx",
                "gumgang-v2/components/layout/ConnectionStatus.tsx",
                "gumgang-v2/app/layout.tsx",
            ],
            operation="edit",
            message="UI: WS-only memory status + ConnectionStatus integration",
        ),
        TaskSpec(
            task_id="B-WS-INIT-HOTFIX",
            notes="Defer app.core import and guard router imports to allow websocket_server usage without core package",
            paths=["backend/app/api/__init__.py"],
            operation="edit",
        ),
        TaskSpec(
            task_id="B-STATUS-WS",
            notes="Report real WebSocket state in /status (on/ready/off) and ws_connections",
            paths=["backend/simple_main.py"],
            operation="edit",
        ),
        TaskSpec(
            task_id="G2-UI-STATUS-BADGE-A",
            notes="Add dual client/server WS badges with periodic /status polling (Option A)",
            paths=[
                "gumgang-v2/components/layout/ConnectionStatus.tsx",
                "gumgang-v2/app/layout.tsx",
            ],
            operation="edit",
        ),
    ]

    # Manifest upserts
    modified_manifest = False
    for t in tasks:
        m = upsert_changeset(manifest, t, ts_kst)
        modified_manifest = modified_manifest or m

    # Update timestamps.updated_at_kst
    tss = manifest.setdefault("timestamps", {})
    if tss.get("updated_at_kst") != ts_kst:
        tss["updated_at_kst"] = ts_kst
        modified_manifest = True
        print("[OK] Updated manifest timestamps.updated_at_kst")

    # Save manifest
    if modified_manifest:
        save_json(manifest_path, manifest, dry_run)
    else:
        print("[INFO] Manifest already up-to-date. No changes written.")

    # Guard audit append
    appended = append_guard_entries(
        guard_log_path,
        ts_kst=ts_kst,
        tasks=[
            # Only include tasks with at least one existing path for audit
            TaskSpec(
                task_id=t.task_id,
                notes=t.notes,
                paths=existing_paths_only(t.paths),
                operation=t.operation,
                risk=t.risk,
                message=t.message,
            )
            for t in tasks
            if existing_paths_only(t.paths)
        ],
        rules_version_str=rules_version_str,
        session_id=session_id,
        blueprint_sha=blueprint_sha,
        dry_run=dry_run,
    )
    if appended == 0:
        print("[INFO] Guard audit already up-to-date. No new lines appended.")

    # Summary
    print("\n=== Sync Summary ===")
    print(f"- Timestamp (KST): {ts_kst}")
    print(f"- Manifest updated: {'YES' if modified_manifest else 'NO'}")
    print(f"- Guard entries appended: {appended}")


# -------------------------
# CLI
# -------------------------

def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="Sync logs/manifest timestamps and append missing changesets/audit entries (Gumgang 2.0)."
    )
    p.add_argument(
        "--dry-run",
        action="store_true",
        help="Do not write files; print planned changes."
    )
    return p.parse_args()


def main() -> None:
    args = parse_args()
    print(f"[INFO] Project root: {ROOT}")
    print(f"[INFO] Dry-run: {args.dry_run}")
    sync_manifest_and_logs(dry_run=args.dry_run)


if __name__ == "__main__":
    main()
