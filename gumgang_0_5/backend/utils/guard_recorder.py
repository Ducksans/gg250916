#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Gumgang 2.0 — Guard Recorder
Add common guard recorder module to append guard_audit.log and update session_manifest.json
with KST timestamps and dedup/locking.

Absolute constraints:
- Timezone: Asia/Seoul (KST), format "YYYY-MM-DD HH:mm"
- Use backend/utils/time_kr.now_kr_str_minute exclusively to generate timestamps
- guard_audit.log is append-only; prepend header if missing
- .session/session_manifest.json uses upsert semantics for changesets
- Deduplicate by (task_id, operation, path)
- File locking to avoid concurrent write corruption
- No external deps

Provided APIs:
- record_audit(task_id, operation, paths, message, risk="SAFE", actor="gpt-5", phase="execute",
               status="success", rules_version=None, session_id=None, blueprint_sha=None) -> int
- record_manifest(task_id, operation, paths, notes, ts_kst=None) -> bool
- record(task_id, operation, paths, notes, message=None, risk="SAFE") -> tuple[int, bool]
- audit_tail(lines=200) -> list[str]

CLI:
  python backend/utils/guard_recorder.py \
    --task G2-UI-STATUS-HUD \
    --op edit \
    --path gumgang-v2/components/layout/StatusHUD.tsx \
    --path gumgang-v2/app/layout.tsx \
    --notes "Add HUD 10s poll" \
    --message "HUD(CPU/MEM/WS) 10s polling"
"""

from __future__ import annotations

import argparse
import fcntl
import io
import json
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Iterable, List, Optional, Sequence, Tuple

# Project root and paths
HERE = Path(__file__).resolve()
ROOT = HERE.parents[2]  # gumgang_0_5/
LOGS_DIR = ROOT / "logs"
SESSION_DIR = ROOT / ".session"
GUARD_LOG = LOGS_DIR / "guard_audit.log"
MANIFEST = SESSION_DIR / "session_manifest.json"
SESSION_CURRENT = SESSION_DIR / "SESSION_CURRENT.json"

# Import KST time util (MUST be used for all timestamps)
import sys

sys.path.insert(0, str((ROOT / "backend").resolve()))
from utils.time_kr import now_kr_str_minute  # type: ignore


@dataclass(frozen=True)
class AuditLine:
    ts_kst: str
    task_id: str
    actor: str
    phase: str
    operation: str
    risk: str
    path: str
    status: str
    message: str
    rules_version: str
    session_id: str
    blueprint_sha: str

    def to_tsv(self) -> str:
        cols = [
            self.ts_kst,
            self.task_id,
            self.actor,
            self.phase,
            self.operation,
            self.risk,
            self.path,
            self.status,
            self.message.replace("\t", " ").strip(),
            self.rules_version,
            self.session_id,
            self.blueprint_sha,
        ]
        return "\t".join(cols)


HEADER_LINES = [
    "# Gumgang 2.0 — Guard Audit Log",
    "# File: logs/guard_audit.log",
    "# Encoding: UTF-8",
    "# Delimiter: TAB",
    "# Timezone: Asia/Seoul (KST)",
    '# Timestamp format: YYYY-MM-DD HH:mm (MUST be generated by backend/utils/time_kr.now_kr_str_minute)',
    "# Write policy: Append-only, one event per line",
    "# Purpose: Record all guarded actions with task_id and verification data for audit and rollback",
    "# Notes:",
    "# - Do NOT remove or modify this header.",
    "# - All entries MUST pass through the approval→guard→execute→verify pipeline.",
    "# - This file may be tailed by monitoring tools.",
    "",
    "ts_kst\ttask_id\tactor\tphase\toperation\trisk\tpath\tstatus\tmessage\trules_version\tsession_id\tblueprint_sha",
]


def _ensure_dirs() -> None:
    LOGS_DIR.mkdir(parents=True, exist_ok=True)
    SESSION_DIR.mkdir(parents=True, exist_ok=True)


def _ensure_guard_header() -> None:
    _ensure_dirs()
    if not GUARD_LOG.exists():
        with open(GUARD_LOG, "w", encoding="utf-8") as f:
            f.write("\n".join(HEADER_LINES) + "\n")
        return
    # Ensure schema line present
    schema = HEADER_LINES[-1]
    with open(GUARD_LOG, "r+", encoding="utf-8") as f:
        data = f.read()
        if schema not in data:
            f.seek(0)
            f.write("\n".join(HEADER_LINES) + "\n" + data)


def _flock_exclusive(fp) -> None:
    fcntl.flock(fp.fileno(), fcntl.LOCK_EX)


def _flock_shared(fp) -> None:
    fcntl.flock(fp.fileno(), fcntl.LOCK_SH)


def _flock_release(fp) -> None:
    fcntl.flock(fp.fileno(), fcntl.LOCK_UN)


def _read_json(path: Path, default: Any) -> Any:
    if not path.exists():
        return default
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default


def _atomic_write(path: Path, text: str) -> None:
    tmp = path.with_suffix(path.suffix + ".tmp")
    with open(tmp, "w", encoding="utf-8") as f:
        f.write(text)
        f.flush()
        os.fsync(f.fileno())
    os.replace(tmp, path)


def _get_rules_version(manifest: dict) -> str:
    rv = ((manifest.get("guard") or {}).get("rules_version")) or "1.1"
    return rv if str(rv).startswith("v") else f"v{rv}"


def _get_session_meta() -> Tuple[str, str]:
    """
    Returns (session_id, blueprint_sha) from SESSION_CURRENT.json, or ('미확인','미확인')
    """
    data = _read_json(SESSION_CURRENT, {})
    session_id = str(data.get("session_id", "미확인"))
    blueprint_sha = str(data.get("blueprint_sha", "미확인"))
    return session_id, blueprint_sha


def _read_existing_audit_keys() -> set[Tuple[str, str, str]]:
    """
    Returns (task_id, operation, path) keys already present in audit log.
    """
    keys: set[Tuple[str, str, str]] = set()
    if not GUARD_LOG.exists():
        return keys
    try:
        with open(GUARD_LOG, "r", encoding="utf-8", errors="ignore") as f:
            _flock_shared(f)
            for line in f:
                if not line or line.startswith("#") or line.startswith("ts_kst\t"):
                    continue
                parts = line.rstrip("\n").split("\t")
                if len(parts) < 7:
                    continue
                task_id = parts[1].strip()
                op = parts[4].strip()
                path = parts[6].strip()
                if task_id and path and op:
                    keys.add((task_id, op, path))
            _flock_release(f)
    except Exception:
        pass
    return keys


def _append_audit_lines(lines: List[AuditLine]) -> int:
    if not lines:
        return 0
    _ensure_guard_header()
    # Dedup against existing
    existing = _read_existing_audit_keys()
    to_write = [ln for ln in lines if (ln.task_id, ln.operation, ln.path) not in existing]
    if not to_write:
        return 0
    buf = io.StringIO()
    for ln in to_write:
        buf.write(ln.to_tsv() + "\n")
    payload = buf.getvalue()
    with open(GUARD_LOG, "a", encoding="utf-8") as f:
        _flock_exclusive(f)
        f.write(payload)
        f.flush()
        os.fsync(f.fileno())
        _flock_release(f)
    return len(to_write)


def _manifest_upsert_changeset(manifest: dict, task_id: str, operation: str, paths: Sequence[str], notes: str, ts_kst: Optional[str]) -> bool:
    modified = False
    changesets: List[dict] = manifest.setdefault("changesets", [])
    # find by task_id
    idx = next((i for i, cs in enumerate(changesets) if cs.get("task_id") == task_id), None)
    valid_paths = [p for p in paths if (ROOT / p).exists()]
    if idx is None:
        entry = {
            "task_id": task_id,
            "ts_kst": ts_kst or now_kr_str_minute(),
            "operation": operation,
            "paths": valid_paths,
            "status": "success",
            "notes": notes,
        }
        changesets.append(entry)
        modified = True
    else:
        cs = changesets[idx]
        # ts_kst fill if empty or '미확인'
        if not cs.get("ts_kst") or str(cs.get("ts_kst")).strip() == "미확인":
            cs["ts_kst"] = ts_kst or now_kr_str_minute()
            modified = True
        # merge paths (set union)
        cur = set(cs.get("paths") or [])
        add = [p for p in valid_paths if p not in cur]
        if add:
            cs["paths"] = list(cur.union(add))
            modified = True
        # ensure notes
        if not cs.get("notes"):
            cs["notes"] = notes
            modified = True
    # timestamps.updated_at_kst
    tss = manifest.setdefault("timestamps", {})
    if tss.get("updated_at_kst") != (ts_kst or now_kr_str_minute()):
        tss["updated_at_kst"] = ts_kst or now_kr_str_minute()
        modified = True
    return modified


def record_audit(
    task_id: str,
    operation: str,
    paths: Sequence[str],
    message: str,
    *,
    risk: str = "SAFE",
    actor: str = "gpt-5",
    phase: str = "execute",
    status: str = "success",
    rules_version: Optional[str] = None,
    session_id: Optional[str] = None,
    blueprint_sha: Optional[str] = None,
    ts_kst: Optional[str] = None,
) -> int:
    """
    Append guard audit lines (dedup by task_id,operation,path). Returns count appended.
    """
    if not paths:
        return 0
    _ensure_dirs()
    ts = ts_kst or now_kr_str_minute()
    manifest = _read_json(MANIFEST, {})
    rv = rules_version or _get_rules_version(manifest)
    sess, bp = _get_session_meta()
    sid = session_id or sess
    bpsha = blueprint_sha or bp
    lines = [
        AuditLine(
            ts_kst=ts,
            task_id=task_id,
            actor=actor,
            phase=phase,
            operation=operation,
            risk=risk,
            path=str(p),
            status=status,
            message=message,
            rules_version=rv,
            session_id=sid,
            blueprint_sha=bpsha,
        )
        for p in paths
    ]
    return _append_audit_lines(lines)


def record_manifest(
    task_id: str,
    operation: str,
    paths: Sequence[str],
    notes: str,
    *,
    ts_kst: Optional[str] = None,
) -> bool:
    """
    Upsert task changeset into session_manifest.json. Returns True if file modified.
    """
    _ensure_dirs()
    manifest = _read_json(MANIFEST, {})
    modified = _manifest_upsert_changeset(manifest, task_id, operation, paths, notes, ts_kst or now_kr_str_minute())
    if modified:
        text = json.dumps(manifest, ensure_ascii=False, indent=2) + "\n"
        # lock and atomic write
        with open(MANIFEST, "a+", encoding="utf-8") as f:
            _flock_exclusive(f)
            _atomic_write(MANIFEST, text)
            _flock_release(f)
    return modified


def record(
    task_id: str,
    operation: str,
    paths: Sequence[str],
    notes: str,
    message: Optional[str] = None,
    *,
    risk: str = "SAFE",
    actor: str = "gpt-5",
) -> Tuple[int, bool]:
    """
    Convenience: record audit + manifest. Returns (audit_appended_count, manifest_modified)
    """
    msg = message or notes
    ts = now_kr_str_minute()
    appended = record_audit(
        task_id=task_id,
        operation=operation,
        paths=paths,
        message=msg,
        risk=risk,
        actor=actor,
        ts_kst=ts,
    )
    modified = record_manifest(
        task_id=task_id,
        operation=operation,
        paths=paths,
        notes=notes,
        ts_kst=ts,
    )
    return appended, modified


def audit_tail(lines: int = 200) -> List[str]:
    """
    Return the last N non-empty lines of the guard audit log (without altering it).
    """
    if not GUARD_LOG.exists():
        return []
    # Efficient tail read
    with open(GUARD_LOG, "rb") as f:
        _flock_shared(f)
        try:
            f.seek(0, os.SEEK_END)
            size = f.tell()
            block = 4096
            data = b""
            while len(data.splitlines()) <= lines + 1 and size > 0:
                read_size = min(block, size)
                size -= read_size
                f.seek(size)
                data = f.read(read_size) + data
            _flock_release(f)
        except Exception:
            _flock_release(f)
            return []
    text = data.decode("utf-8", errors="ignore")
    all_lines = [ln for ln in text.splitlines() if ln.strip()]
    return all_lines[-lines:]


# ---------------------------
# CLI
# ---------------------------

def _parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Gumgang Guard Recorder — append audit and update manifest (KST timestamps).")
    p.add_argument("--task", required=True, help="Task ID (e.g., G2-UI-STATUS-HUD)")
    p.add_argument("--op", default="edit", help="Operation (edit/create/mkdir/mv/checkpoint)")
    p.add_argument("--path", dest="paths", action="append", default=[], help="Path to record (repeatable)")
    p.add_argument("--notes", default="", help="Notes for manifest changeset")
    p.add_argument("--message", default=None, help="Message for audit (defaults to notes)")
    p.add_argument("--risk", default="SAFE", help="Risk level (SAFE/CAUTION/DANGEROUS)")
    p.add_argument("--actor", default="gpt-5", help="Actor (default: gpt-5)")
    p.add_argument("--dry-run", action="store_true", help="Print actions without writing files")
    return p.parse_args()


def _main() -> None:
    args = _parse_args()
    if not args.paths:
        print("[guard_recorder] No paths provided; nothing to record.")
        return
    if args.dry_run:
        ts = now_kr_str_minute()
        print(f"[DRY-RUN] Would record at {ts} (KST)")
        print(f"  Task: {args.task}")
        print(f"  Op:   {args.op}")
        print(f"  Paths:")
        for p in args.paths:
            print(f"    - {p}")
        print(f"  Notes:   {args.notes}")
        print(f"  Message: {args.message or args.notes}")
        return

    appended, modified = record(
        task_id=args.task,
        operation=args.op,
        paths=args.paths,
        notes=args.notes,
        message=args.message,
        risk=args.risk,
        actor=args.actor,
    )
    print(f"[guard_recorder] audit_appended={appended}, manifest_modified={modified}")


if __name__ == "__main__":
    _main()
